# 简易网络库

本网络库是对 Raw Socket 包含少量自定义协议的简单封装，提供成员发现、地址同步、组播收发和TCP连接建立等功能。内部实现使用 [Dependency](../Dependency) 提供的依赖项管理功能来组织各个功能模块。

## 概述

### 设计思路

本协议框架由 3 部分组成：

- 成员发现和地址同步
- 不可靠的数据广播和可靠连接的建立
- 供开发者扩展自定义功能的接口 

### 结构

本网络库主要提供局域网内连接和通信功能，因此大部分工作通过局域网组播实现。其中各个组件通过 Dependency 定义的 `DynamicScope` 联系起来，因此不一定能够独立工作，但总的来说分为 2 种：

* 资源 `Resources`

  资源的概念类似于全局变量，是所有功能模块行使功能所共同依赖的信息或系统资源，包括套接字、本地网络环境和组成员地址等。

  **资源必定不依赖其他组件，因此甚至可以不在域中使用。**

* 功能模块 `Modules`

  功能模块主要封装了协议、算法等，可能还包含私有的状态信息。

  **许多功能模块包含严格的组件依赖，因此无法在域外使用。**

## 使用

要使用库提供的功能，开发者可以自己构造一个动态域，并添加需要的功能模块，但这可能需要对组件依赖关系非常熟悉。因此我们推荐使用预先构建的常用组件集，其中已经包含完成特定功能所需的组件，并将一些组件功能封装成了更容易调用的方法。

下面针对基于组播通信的流程介绍一些预置组件集。

### step1 打开

要进行组播通信，发送方和接收方很可能是不对等的。与广播不同，组播必须指定从从哪个网络接口发送。想要向多个局域网发送则必须打开多个发送套接字（或每次发送时修改套接字的网络接口，可能存在性能问题且多线程下需要同步，因此没有这样使用）。

> 这是因为组播地址和单播地址是并列的，而广播地址（或者说子网地址）是基于单播地址，因此当打开单播或广播套接字时，其实已经指定了对应的子网，但组播地址、组播套接字与子网不存在这种对应关系。

若用户有多个网卡、连接到多个局域网，又对局域网没有认识，可能不知道应该打开哪些接口。对于接收的情况比较简单，即使多绑定了，只要没有相同组播地址和端口的数据到来就没有性能损耗，可以直接监听本机的所有网络接口，但发送方若打开了无用的网络接口将导致发送的耗时成倍增加。此时比较方便的方案是使用*起搏器*  `Pacemaker`。

起搏器包含了本地网络扫描和组播发送的组件。构造时，将扫描本地网卡情况并打开与网络接口数量相同的套接字用于向所有网络接口发送。因此可以**在组中某个节点所在的设备上打开一个起搏器**，并通过起搏器定时发送激发包。其他节点启动时只要监听所有网络接口，就能在正确的网络接口上收到激发包，再打开激发包到来的子网接口即可。

启动起搏器的代码范例如下：

```c#
private static async Task Main() {
    var pacemaker = new Pacemaker();
	while (true) {
		pacemaker.Activate();
		await Task.Delay(1000);
	}
}
```

确认所有目标节点都上线之后，可以关闭起搏器。

### step2 诊断

要查看组中已经上线的节点，我们推荐使用*探针* `Probe`。探针包含了所有节点信息的接收和存储功能，能查看最后出现时间、IP 地址和 TCP Server 端口。由于只查看不发送，不会影响其他节点，使用也没什么要求。

```c#
private static void Main() {
	var probe = new Probe();
	new Thread(() => {
		           while (true) probe.Invoke();
	           }).Start();

    while (true) {
		Console.ReadKey();
		Console.WriteLine($"{DateTime.Now}:");
		foreach (var (name, (time, address)) in probe.View)
			Console.WriteLine($"{name}: {time}, {address}");
		Console.WriteLine("___");
	}
}
```

### step3 使用

要使用网络库的全部功能，我们推荐包含了所有组件的 `RemoteHub` 类。

#### 常用属性和方法指南

* 构造

  ```c#
  public RemoteHub(string              name              = null,
                   uint                size              = 0x4000,
                   IPEndPoint          group             = null,
                   Action<string>      newMemberDetected = null,
                   params IComponent[] additions);
  ```

  * `name` 名字是远程终端的唯一标识，请在线下保证远程终端的名字不发生重复，否则可能出现意料之外的结果（包括但不限于收到不想要的数据包、无法建立连接等）；
  * `size` UDP 主动分片机制的最大包长度，根据本地网络的具体情况设置，不可以超过65536；
  * `group` 组播地址，需要通过线下商定得知，默认值为 `233.33.33.33:23333`；
  * `newMemberDetected` 发现新成员上线时将调用这个回调函数；
  * `additions` 通过可变长参数为远程终端添加额外组件，若使用标注参数，需要显式构造数组传入；

* 查看信息

  ```c#
  public IPEndPoint Group;
  ```

  查看远程终端所在的组播组。

* 查看组件

  ```c#
  public IEnumerable<IComponent> Modules;
  ```

  查看远程终端已加载的所有组件；

* 网络管理

  ```c#
  public MulticastMonitor Monitor;
  ```

  获取当前远程节点的组播网络管理器。

  > 关于网络管理器的细节查看[这里](Modules/Multicast/MulticastMonitor.cs)。

* 查看已发现成员

  ```c#
  public List<string> this[TimeSpan timeout] { get; }
  ```

  查看超时时间内出现的组成员。

  > 所谓“出现”，指的是发出的任意类型的组播包被此远程终端接收。

  ```c#
  public IPEndPoint this[string name]        { get; }
  ```

  查看特定组成员的地址和端口。

* 处理组播包

  ```c#
  public RemotePacket Invoke();
  ```

  关于组播的具体处理流程，库已经做了封装，但由于库不承担调度功能，需要用户主动调用这个函数进行处理任务的调度。调用时将阻塞调用线程以等待 UDP 包到来。接收到包时将自动进行处理，并将初步解析的包返回。

  注意，由于这个函数内部不包含任何循环流程，收到任何包都将导致一次返回，若这个包就来自这个远程终端本身，将返回 `null`。

* 处理 TCP 连接

  ```c#
  public void Accept();
  ```

  此函数阻塞的情况与 `Invoke()` 相同。但保持TCP连接期间，线程将持续阻塞，因此要同时处理多个TCP连接，可以开启多个线程，线程阻塞期间并不占用 CPU 时间。

> 要了解详情，建议直接查看[源码](Presets/RemoteHub.cs)，有比较详细的文档。

## 注意事项

* TCP 建立连接

  默认状况下，第一次建立 TCP 连接必定会失败，因为还不知道对方的地址和端口。如果对方已经上线，将收到询问并回复。此时隔一段时间重试就能成功建立连接了。